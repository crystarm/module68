INT ophlt := 0;
INT opmovimm := 1;
INT opsys := 2;

PROC memclear = (REF []INT mem) VOID:
BEGIN
    FOR i FROM LWB mem TO UPB mem DO
        mem[i] := 0
    OD
END;

PROC regsreset = (REF []INT r) VOID:
BEGIN
    FOR i FROM LWB r TO UPB r DO
        r[i] := 0
    OD
END;

PROC loaddemo = (REF []INT mem) INT:
BEGIN
    INT p := 0;

    PROC emit = (INT x) VOID:
    BEGIN
        mem[p] := x;
        p := p + 1
    END;

    emit(opmovimm); emit(0); emit(72);
    emit(opsys); emit(1);

    emit(opmovimm); emit(0); emit(105);
    emit(opsys); emit(1);

    emit(opmovimm); emit(0); emit(10);
    emit(opsys); emit(1);

    emit(ophlt);

    p
END;

PROC streq = (STRING a, STRING b) BOOL:
BEGIN
    INT al := LWB a;
    INT au := UPB a;
    INT bl := LWB b;
    INT bu := UPB b;

    IF au - al /= bu - bl THEN
        FALSE
    ELSE
        BOOL ok := TRUE;
        INT i := 0;
        WHILE ok AND i <= au - al DO
            ok := a[al + i] = b[bl + i];
            i := i + 1
        OD;
        ok
    FI
END;

PROC ism68 = (STRING s) BOOL:
BEGIN
    INT l := LWB s;
    INT u := UPB s;

    STRING t := ".m68";
    INT tl := LWB t;

    IF u - l + 1 < 4 THEN
        FALSE
    ELSE
        s[u - 3] = t[tl] AND
        s[u - 2] = t[tl + 1] AND
        s[u - 1] = t[tl + 2] AND
        s[u] = t[tl + 3]
    FI
END;

PROC loadm68 = (STRING path, REF []INT mem, REF INT codesz) BOOL:
BEGIN
    FILE f;
    INT status := open(f, path, stand in channel);

    IF status /= 0 THEN
        FALSE
    ELSE
        BOOL eoflag := FALSE;
        BOOL bad := FALSE;

        on logical file end(f, (REF FILE infile) BOOL:
        BEGIN
            eoflag := TRUE;
            TRUE
        END);

        on value error(f, (REF FILE infile) BOOL:
        BEGIN
            bad := TRUE;
            TRUE
        END);

        PROC rd = (REF INT x) BOOL:
        BEGIN
            IF eoflag OR bad THEN
                FALSE
            ELSE
                get(f, x);
                NOT (eoflag OR bad)
            FI
        END;

        BOOL ok := TRUE;

        INT b0, b1, b2, b3;
        INT ver, flags, szhi, szlo;

        IF ok THEN ok := rd(b0) FI;
        IF ok THEN ok := rd(b1) FI;
        IF ok THEN ok := rd(b2) FI;
        IF ok THEN ok := rd(b3) FI;

        IF NOT ok THEN
            close(f);
            FALSE
        ELIF b0 /= 77 OR b1 /= 54 OR b2 /= 56 OR b3 /= 33 THEN
            close(f);
            FALSE
        ELSE
            ok := rd(ver);
            IF ok THEN ok := rd(flags) FI;
            IF ok THEN ok := rd(szhi) FI;
            IF ok THEN ok := rd(szlo) FI;

            IF NOT ok THEN
                close(f);
                FALSE
            ELSE
                codesz := szhi * 256 + szlo;

                IF codesz < 0 OR codesz > UPB mem - LWB mem + 1 THEN
                    close(f);
                    FALSE
                ELSE
                    INT i := 0;
                    WHILE ok AND i < codesz DO
                        INT x;
                        ok := rd(x);
                        IF ok THEN
                            mem[i] := x
                        FI;
                        i := i + 1
                    OD;

                    close(f);
                    ok
                FI
            FI
        FI
    FI
END;

PROC vmstep = (REF []INT r, REF INT ip, REF BOOL running, REF []INT mem, BOOL trace) VOID:
BEGIN
    INT ip0 := ip;
    INT op := mem[ip];
    ip := ip + 1;

    IF trace THEN
        put(stand error, ("ip=", whole(ip0, 0),
                         " op=", whole(op, 0),
                         " r0=", whole(r[0], 0),
                         " r1=", whole(r[1], 0),
                         " r2=", whole(r[2], 0),
                         " r3=", whole(r[3], 0),
                         new line))
    FI;

    IF op = ophlt THEN
        running := FALSE
    ELIF op = opmovimm THEN
    BEGIN
        INT a := mem[ip];
        INT imm := mem[ip + 1];
        ip := ip + 2;

        IF a < LWB r OR a > UPB r THEN
            running := FALSE
        ELSE
            r[a] := imm
        FI
    END
    ELIF op = opsys THEN
    BEGIN
        INT n := mem[ip];
        ip := ip + 1;

        IF n = 0 THEN
            print((whole(r[0], 0)))
        ELIF n = 1 THEN
            print((REPR r[0]))
        FI
    END
    ELSE
        running := FALSE
    FI
END;

BEGIN
    INT memsz := 65536;

    REF []INT mem;
    mem := HEAP [0:memsz - 1]INT;
    memclear(mem);

    INT codesz := 0;
    BOOL ok := FALSE;
    BOOL trace := FALSE;

    IF argc > 0 THEN
        FOR i FROM 1 TO argc DO
            STRING arg := argv(i);
            IF streq(arg, "--trace") THEN
                trace := TRUE
            ELIF NOT ok AND ism68(arg) THEN
                ok := loadm68(arg, mem, codesz)
            FI
        OD
    FI;

    IF NOT ok THEN
        codesz := loaddemo(mem)
    FI;

    REF []INT r;
    r := HEAP [0:7]INT;
    regsreset(r);

    INT ip := 0;
    BOOL running := TRUE;

    INT steps := 0;
    INT maxsteps := 10000000;

    WHILE running AND steps < maxsteps DO
        vmstep(r, ip, running, mem, trace);
        steps := steps + 1
    OD;

    IF steps >= maxsteps THEN
        put(stand error, ("max steps reached", new line))
    FI;

    SKIP
END
